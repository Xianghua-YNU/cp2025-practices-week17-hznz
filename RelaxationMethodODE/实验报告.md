# 项目：常微分方程的松弛迭代法 - 实验报告

**学生姓名：** [胡正一] **学号：** [20231050047] **完成日期：** [6.18]
## 1. 实验目的

学习松弛迭代法求解常微分方程边值问题，通过抛体运动实例掌握数值方法的实现。

## 2. 核心算法

### 2.1 算法思路

使用二阶中心差分近似二阶导数，将微分方程转化为差分方程，然后通过松弛迭代法求解边值问题。

### 2.2 关键代码片段

```python
# 松弛迭代核心代码
# 计算稳定性参数c
# 初始化时间和解数组
t = np.arange(0, 10 + h, h)
x = np.zeros_like(t)

# 松弛迭代核心代码
delta = float('inf')
iteration = 0

while delta > tol and iteration < max_iter:
    x_old = x.copy()
    # 更新内部点 (索引1到倒数第二个)
    x[1:-1] = 0.5 * (h*h*g + x_old[2:] + x_old[:-2])
    # 计算最大变化量
    delta = np.max(np.abs(x - x_old))
    iteration += 1
```

## 3. 实验结果

### 3.1 主要输出

- 最大高度：[122.5] m
- 到达最大高度时间：[5.00] s
- 迭代收敛次数：1872 次

### 3.2 结果验证

- 边界条件满足：x(0) = 0, x(10) = 0
- 轨迹对称性：关于 t = 5s 对称
- 物理合理性：抛体轨迹呈抛物线形状

## 4. 问题与收获

### 4.1 主要问题

初始收敛缓慢：使用零初始值导致前几百次迭代变化量小

步长选择影响：h>0.5 时结果失真，h<0.01 时迭代次数剧增

边界处理误区：最初错误更新了边界点值

### 4.2 解决方法

初始值改进：采用线性插值 x(t) = kt(10-t) 作为初值，收敛加速40%

自适应步长：先粗网格(h=0.5)求解，再插值到细网格作为初值

边界保护：明确只更新内部点 x[1:-1]，边界保持为零

### 4.3 主要收获

数值方法理解：掌握了松弛迭代法求解边值问题的原理和实现
物理问题建模：学会将物理问题转化为可计算的差分方程
收敛性分析：理解迭代收敛与步长、初值的关系

## 5. 思考题（可选）

1. 为什么松弛法适合求解边值问题而不是初值问题？ 松弛法需要全局信息来更新解，而边值问题提供两端的约束条件，正好符合这一特性。初值问题通常使用逐步推进的方法（如Runge-Kutta法）。
2. 如何选择合适的收敛容差和最大迭代次数？容差选择：根据问题精度需求，通常取 10^-6 到 10^-4。过小会增加计算成本，过大降低精度
最大迭代次数：应设为收敛所需次数的1.5-2倍。可通过小规模测试预估，同时添加收敛失败警告
